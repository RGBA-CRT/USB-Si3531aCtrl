TypeDef FT_HANDLE = Long
TypeDef FT_STATUS = Long

Declare Sub Init_libMPSSE	 CDECL Lib "libMPSSE.dll" ()
Declare Sub Cleanup_libMPSSE CDECL Lib "libMPSSE.dll" ()

Declare Function SPI_GetNumChannels	CDECL Lib "libMPSSE.dll" (nChannle AS *DWord) As FT_STATUS
Declare Function SPI_GetChannelInfo	CDECL Lib "libMPSSE.dll" (index AS DWord,ByRef chInfo AS FT_DEVICE_LIST_INFO_NODE) As FT_STATUS
Declare Function SPI_OpenChannel 	CDECL Lib "libMPSSE.dll" (index AS DWord,ByRef handle AS FT_HANDLE) As FT_STATUS
Declare Function SPI_InitChannel 	CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE, config as *LibMPSSE_CHANNEL_CONFIG) AS FT_STATUS
Declare Function SPI_CloseChannel 	CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE ) AS FT_STATUS
Declare Function SPI_Read 			CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE,buf AS BytePtr,size As DWord,ByRef dwAB as DWord,opt As DWord) AS FT_STATUS
Declare Function SPI_Write 			CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE,buf AS BytePtr,size As DWord,ByRef dwAB as DWord,opt As DWord) AS FT_STATUS
Declare Function SPI_ReadWrite		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE,inBuffer AS BytePtr,outBuffer AS BytePtr,size AS DWord,ByRef dwAB aS DWord,opt AS DWord) AS FT_STATUS
Declare Function SPI_IsBusy 		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE,ByRef state AS Long) AS FT_STATUS
Declare Function SPI_ChangeCS 		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE, config as *LibMPSSE_CHANNEL_CONFIG) AS FT_STATUS
Declare Function FT_WriteGPIO 		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE, dir As Byte,value AS DWord) AS FT_STATUS
Declare Function FT_ReadGPIO		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE, value AS *Byte) AS FT_STATUS
'Declare Function SPI_ToggleCS 		CDECL Lib "libMPSSE.dll" (handle AS FT_HANDLE, state AS Long) AS FT_STATUS

Type FT_DEVICE_LIST_INFO_NODE
	Flags As DWord
	devType As DWord
	ID As DWord
	LocId As DWord
	SerialNumber[15] As Byte
	Description [63]As Byte
	ftHandle As FT_HANDLE
EndType

Type LibMPSSE_CHANNEL_CONFIG
	ClockRate AS DWord
	LatencyTimer AS Byte

	configOptions AS DWord	/*This member provides a way to enable/disable features
	specific to the protocol that are implemented in the chip
	BIT1-0=CPOL-CPHA:	00 - MODE0 - data captured on rising edge, propagated on falling
 						01 - MODE1 - data captured on falling edge, propagated on rising
 						10 - MODE2 - data captured on falling edge, propagated on rising
 						11 - MODE3 - data captured on rising edge, propagated on falling
	BIT4-BIT2: 000 - A/B/C/D_DBUS3=ChipSelect
			 : 001 - A/B/C/D_DBUS4=ChipSelect
 			 : 010 - A/B/C/D_DBUS5=ChipSelect
 			 : 011 - A/B/C/D_DBUS6=ChipSelect
 			 : 100 - A/B/C/D_DBUS7=ChipSelect
 	BIT5: ChipSelect is active high if this bit is 0
	BIT6 -BIT31		: Reserved
	*/

	Pin AS DWord/*BIT7   -BIT0:   Initial direction of the pins	*/
					/*BIT15 -BIT8:   Initial values of the pins		*/
					/*BIT23 -BIT16: Final direction of the pins		*/
					/*BIT31 -BIT24: Final values of the pins		*/
	reserved AS Word
	dummy[24] AS Byte
End Type

/* Bit defination of the transferOptions parameter in SPI_Read, SPI_Write & SPI_Transfer  */
/* transferOptions-Bit0: If this bit is 0 then it means that the transfer size provided is in bytes */
Const	SPI_TRANSFER_OPTIONS_SIZE_IN_BYTES			= &H00000000
/* transferOptions-Bit0: If this bit is 1 then it means that the transfer size provided is in bytes */
Const	SPI_TRANSFER_OPTIONS_SIZE_IN_BITS			= &H00000001
/* transferOptions-Bit1: if BIT1 is 1 then CHIP_SELECT line will be enabled at start of transfer */
Const	SPI_TRANSFER_OPTIONS_CHIPSELECT_ENABLE		= &H00000002
/* transferOptions-Bit2: if BIT2 is 1 then CHIP_SELECT line will be disabled at end of transfer */
Const SPI_TRANSFER_OPTIONS_CHIPSELECT_DISABLE		= &H00000004

/* Bit defination of the Options member of configOptions structure*/
Const SPI_CONFIG_OPTION_MODE_MASK		= &H00000003
Const SPI_CONFIG_OPTION_MODE0			= &H00000000
Const SPI_CONFIG_OPTION_MODE1			= &H00000001
Const SPI_CONFIG_OPTION_MODE2			= &H00000002
Const SPI_CONFIG_OPTION_MODE3			= &H00000003
Const SPI_CONFIG_OPTION_CS_MASK			= &H0000001C		/*111 00*/
Const SPI_CONFIG_OPTION_CS_DBUS3		= &H00000000		/*000 00*/
Const SPI_CONFIG_OPTION_CS_DBUS4		= &H00000004		/*001 00*/
Const SPI_CONFIG_OPTION_CS_DBUS5		= &H00000008		/*010 00*/
Const SPI_CONFIG_OPTION_CS_DBUS6		= &H0000000C		/*011 00*/
Const SPI_CONFIG_OPTION_CS_DBUS7		= &H00000010		/*100 00*/
Const SPI_CONFIG_OPTION_CS_ACTIVELOW	= &H00000020

Const FT_OK = 0

enum I2C_CLOCKRATE
	I2C_CLOCK_STANDARD_MODE = 100000						/* 100kb/sec */
	I2C_CLOCK_FAST_MODE = 400000							/* 400kb/sec */
	I2C_CLOCK_FAST_MODE_PLUS = 1000000  					/* 1000kb/sec */
	I2C_CLOCK_HIGH_SPEED_MODE = 3400000 					/* 3.4Mb/sec */
End Enum
/* Options to I2C_DeviceWrite & I2C_DeviceRead */
/*Generate start condition before transmitting */
Const	I2C_TRANSFER_OPTIONS_START_BIT		= &H00000001

/*Generate stop condition before transmitting */
Const I2C_TRANSFER_OPTIONS_STOP_BIT		= &H00000002

/*Continue transmitting data in bulk without caring about Ack or nAck from device if this bit is 
not set. If this bit is set then stop transitting the data in the buffer when the device nAcks*/
Const I2C_TRANSFER_OPTIONS_BREAK_ON_NACK	= &H00000004

/* libMPSSE-I2C generates an ACKs for every byte read. Some I2C slaves require the I2C 
master to generate a nACK for the last data byte read. Setting this bit enables working with such 
I2C slaves */
Const I2C_TRANSFER_OPTIONS_NACK_LAST_BYTE	= &H00000008

/* no address phase, no USB interframe delays */
Const I2C_TRANSFER_OPTIONS_FAST_TRANSFER_BYTES	= &H00000010
Const I2C_TRANSFER_OPTIONS_FAST_TRANSFER_BITS	= &H00000020
Const I2C_TRANSFER_OPTIONS_FAST_TRANSFER		= &H00000030

/* if I2C_TRANSFER_OPTION_FAST_TRANSFER is set then setting this bit would mean that the 
address field should be ignored. The address is either a part of the data or this is a special I2C
frame that doesn't require an address*/
Const I2C_TRANSFER_OPTIONS_NO_ADDRESS		= &H00000040

Const I2C_CMD_GETDEVICEID_RD	= &HF9
Const I2C_CMD_GETDEVICEID_WR	= &HF8

Const I2C_GIVE_ACK	=	1
Const I2C_GIVE_NACK =	0

/* 3-phase clocking is enabled by default. Setting this bit in ConfigOptions will disable it */
Const I2C_DISABLE_3PHASE_CLOCKING	= &H0001

/* The I2C master should actually drive the SDA line only when the output is LOW. It should be
tristate the SDA line when the output should be high. This tristating the SDA line during output 
HIGH is supported only in FT232H chip. This feature is called DriveOnlyZero feature and is 
enabled when the following bit is set in the options parameter in function I2C_Init */
Const I2C_ENABLE_DRIVE_ONLY_ZERO	= &H0002

Type ChannelConfig
	ClockRate AS I2C_CLOCKRATE
	LatencyTimer AS Byte
	Options AS DWord
End Type


Declare Function I2C_GetNumChannels	CDECL Lib "libMPSSE.dll" (numChannels AS *DWord) AS FT_STATUS
Declare Function I2C_GetChannelInfo	CDECL Lib "libMPSSE.dll" (index AS DWord, chanInfo AS *FT_DEVICE_LIST_INFO_NODE) AS FT_STATUS
Declare Function I2C_OpenChannel	CDECL Lib "libMPSSE.dll" (index aS DWord, handle AS *FT_HANDLE) AS FT_STATUS
Declare Function I2C_InitChannel	CDECL Lib "libMPSSE.dll" (handle As FT_HANDLE,ByRef config AS ChannelConfig) AS FT_STATUS
Declare Function I2C_CloseChannel	CDECL Lib "libMPSSE.dll" (handle As FT_HANDLE) AS FT_STATUS
Declare Function I2C_DeviceRead 	CDECL Lib "libMPSSE.dll" (handle As FT_HANDLE, deviceAddress AS DWord, sizeToTransfer AS DWord,buffer AS BytePtr,ByRef sizeTransfered AS DWord, options AS DWord) AS FT_STATUS
Declare Function I2C_DeviceWrite	CDECL Lib "libMPSSE.dll" (handle As FT_HANDLE, deviceAddress AS DWord, sizeToTransfer AS DWord,buffer AS BytePtr,ByRef sizeTransfered AS DWord, options AS DWord) AS FT_STATUS
